/*
 * ta-solve
 *
 * The unnamed Tin Arm solver API
 *
 * API version: 1.0
 * Contact: api@tinarmengineering.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"encoding/json"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/tinarmengineering/tinarm-api-srv/go/dbo"

	amqp "github.com/rabbitmq/amqp091-go"
)

// DeleteJobsId - Delete Job
func DeleteJobsId(c *gin.Context) {

	var job dbo.Job
	dbo.DB.Delete(&job, c.Param("id"))

	c.JSON(http.StatusOK, gin.H{})
}

// GetJobsId - Get Job
func GetJobsId(c *gin.Context) {

	var job dbo.Job
	dbo.DB.First(&job, c.Param("id"))

	if job.ID == 0 {
		c.JSON(http.StatusNotFound, gin.H{})
	} else {
		c.JSON(http.StatusOK, job)
	}
}

// PostRectanglejobs - Create RectangleJob
func PostRectanglejobs(c *gin.Context) {

	var rJob Rectanglejob
	err := c.BindJSON(&rJob)
	if err != nil {
		c.JSON(http.StatusBadRequest, err)
		return
	}

	rJobGeomotry, err := json.Marshal(rJob.Geometry)
	if err != nil {
		c.JSON(http.StatusBadRequest, err)
		return
	}

	var newJob = dbo.Job{Data: string(rJobGeomotry)}
	dbo.DB.Create(&newJob)

	body := "{\"id\":\"" +
		strconv.Itoa(int(newJob.ID)) +
		"\", \"data\":" +
		string(rJobGeomotry) +
		", \"nextstep\":null}"

	enqueue(body)

	c.JSON(http.StatusOK, gin.H{})
}

// PostStatorjobs - Create StatorJob
func PostStatorjobs(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{})
}

// Post to RabbitMQ
func enqueue(body string) {

	conn, err := amqp.Dial("amqp://guest:guest@localhost:5672/")
	failOnError(err, "Failed to connect to RabbitMQ")
	defer conn.Close()

	ch, err := conn.Channel()
	failOnError(err, "Failed to open a channel")
	defer ch.Close()

	q, err := ch.QueueDeclare(
		"rectangle_mesh_queue", // name
		true,                   // durable
		false,                  // delete when unused
		false,                  // exclusive
		false,                  // no-wait
		nil,                    // arguments
	)
	failOnError(err, "Failed to declare a queue")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	err = ch.PublishWithContext(ctx,
		"",     // exchange
		q.Name, // routing key
		false,  // mandatory
		false,  // immediate
		amqp.Publishing{
			ContentType: "text/plain",
			Body:        []byte(body),
		})
	failOnError(err, "Failed to publish a message")
	log.Printf(" [x] Sent %s\n", body)
}

func failOnError(err error, msg string) {
	if err != nil {
		log.Panicf("%s: %s", msg, err)
	}
}
